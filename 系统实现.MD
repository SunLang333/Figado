# Figado 项目详细文档

## 1. 引言

本文档详细记录了 Figado 项目的技术细节，包括数据库结构、Django Models 设计、项目整体架构、以及已实现各项功能的代码和逻辑解释。

## 2. 数据库结构 (Database Structure)

Django 根据定义的 Models 自动生成和管理数据库表结构。以下是本项目中主要的数据表及其字段的详细说明。

### 2.1. 用户认证相关表 (Django Auth Tables)

Django 的 `django.contrib.auth` 应用会创建一系列表来管理用户、用户组和权限。由于我们使用了 `AbstractUser` 作为 `CustomUser` 的基类，大部分用户核心字段都存储在 `users_customuser` 表中，但以下辅助表仍然重要：

- `auth_group`: 存储用户组信息。
  - `id` (Primary Key, Integer)
  - `name` (Varchar, Unique): 组名。
- `auth_permission`: 存储所有可用权限的信息。
  - `id` (Primary Key, Integer)
  - `name` (Varchar)
  - `content_type_id` (Foreign Key to `django_content_type`)
  - `codename` (Varchar)
- `auth_group_permissions`: 存储用户组与其权限之间的多对多关系。
  - `id` (Primary Key, Integer)
  - `group_id` (Foreign Key to `auth_group`)
  - `permission_id` (Foreign Key to `auth_permission`)
- `users_customuser_groups`: 存储用户与其所属用户组之间的多对多关系 (由 `CustomUser.groups` 字段自动创建)。
  - `id` (Primary Key, Integer)
  - `customuser_id` (Foreign Key to `users_customuser`)
  - `group_id` (Foreign Key to `auth_group`)
- `users_customuser_user_permissions`: 存储用户与其特定权限之间的多对多关系 (由 `CustomUser.user_permissions` 字段自动创建)。
  - `id` (Primary Key, Integer)
  - `customuser_id` (Foreign Key to `users_customuser`)
  - `permission_id` (Foreign Key to `auth_permission`)

### 2.2. `users_customuser` 表 (用户表)

此表由 `users.models.CustomUser` 模型生成，用于存储用户信息。

- `id`: (Primary Key, Integer, Auto-incrementing) - 用户唯一标识符。
- `password`: (Varchar) - 用户密码 (存储的是哈希值)。
- `last_login`: (Datetime, Nullable) - 用户最后登录时间。
- `is_superuser`: (Boolean) - 标记用户是否为超级用户。
- `username`: (Varchar, Unique) - 用户名。
- `first_name`: (Varchar, Nullable) - 名字。
- `last_name`: (Varchar, Nullable) - 姓氏。
- `email`: (Varchar, Nullable) - 电子邮箱。
- `is_staff`: (Boolean) - 标记用户是否可以访问 Django Admin 后台。
- `is_active`: (Boolean) - 标记用户账户是否激活。
- `date_joined`: (Datetime) - 用户注册时间。
- `languages`: (JSON) - 存储用户的语言偏好列表，例如 `["cn", "en"]`。默认为空列表。

### 2.3. `books_book` 表 (书籍表)

此表由 `books.models.Book` 模型生成，用于存储书籍的详细信息。

- `id`: (Primary Key, Integer, Auto-incrementing) - Django 默认添加的主键。
- `uuid`: (UUID, Unique, Indexed) - 书籍的全局唯一标识符。
- `title`: (Varchar) - 书名。
- `author`: (Varchar) - 作者。
- `language`: (Varchar) - 书籍语言。
- `category`: (Varchar) - 书籍分类。
- `tags`: (Varchar, Nullable) - 标签，可为空。
- `description`: (Text, Nullable) - 书籍描述，可为空。
- `publisher`: (Varchar, Nullable) - 出版商，可为空。
- `publish_date`: (Date, Nullable) - 出版日期，可为空。
- `isbn`: (Varchar, Nullable) - ISBN 号，可为空。
- `page_count`: (Integer, Nullable) - 页数，可为空。
- `visibility`: (Varchar) - 可见性设置 ('public' 或 'private')，默认为 'public'。
- `allow_comments`: (Boolean) - 是否允许评论，默认为 True。
- `cover_image`: (Varchar, Nullable) - 封面图片文件的存储路径，可为空。
- `book_file`: (Varchar, Nullable) - 书籍文件 (如 EPUB) 的存储路径，可为空。
- `user_id`: (Integer, Foreign Key to `users_customuser.id`, Indexed) - 关联到上传该书籍的用户。
- `created_at`: (Datetime) - 书籍记录创建时间，自动记录。
- `updated_at`: (Datetime) - 书籍记录最后更新时间，自动记录。
- `rating`: (Float/Real) - 书籍评分，默认为 0。

**字段类型说明:**

- `Varchar`: 对应 Django 的 `CharField`，用于存储可变长度的字符串。
- `Text`: 对应 Django 的 `TextField`，用于存储大量文本。
- `Integer`: 对应 Django 的 `IntegerField` 或自动创建的主键。
- `Boolean`: 对应 Django 的 `BooleanField`。
- `Date`: 对应 Django 的 `DateField`。
- `Datetime`: 对应 Django 的 `DateTimeField`。
- `UUID`: 对应 Django 的 `UUIDField`。
- `JSON`: 对应 Django 的 `JSONField`。
- `Float/Real`: 对应 Django 的 `FloatField`。

**关系:**

- `books_book.user_id` 是一个外键，指向 `users_customuser.id`，表示一本书籍属于一个用户 (一个用户可以有多本书籍)。
- `users_customuser` 与 `auth_group` 和 `auth_permission` 之间存在多对多关系，通过 `users_customuser_groups` 和 `users_customuser_user_permissions` 中间表实现。

## 3. Django Models 结构 (Django Models Structure)

### 3.1. `users.models.CustomUser`

该模型扩展了 Django 内置的 `AbstractUser` 模型，用于存储用户信息。

```pseudocode
// File: d:\Documents\GitHub\Figado\bookapp_django\users\models.py

// Import necessary modules from Django for models and authentication.

// Define a CustomUser class that inherits from AbstractUser.
// This class extends the standard user model.
//   Add a 'languages' field:
//     Type: JSONField (stores a list of strings).
//     Default: an empty list.
//     Allows blank: True.
//     Help text: "Preferred languages".
//     Purpose: To store user's preferred languages, e.g., ["cn", "en"].
```

**字段说明:**

- 继承自 `AbstractUser` 的所有字段 (例如: `username`, `password`, `email`, `first_name`, `last_name`, `is_staff`, `is_active`, `date_joined` 等)。
- `languages`: JSON 字段，用于存储用户的语言偏好列表。默认为一个空列表。例如: `["cn", "en"]`。

### 3.2. `books.models.Book`

该模型用于存储书籍的详细信息和元数据。

```pseudocode
// File: d:\Documents\GitHub\Figado\bookapp_django\books\models.py

// Import necessary modules: Django models, settings, os, uuid.

// Define function book_file_path(instance, filename):
//   Extract file extension.
//   Generate a unique filename using UUID.
//   Return path "books/<uuid>.<ext>".

// Define function cover_image_upload_path(instance, filename):
//   Extract file extension.
//   Ensure instance has a UUID, generate if not.
//   Set filename to "cover.<ext>".
//   Return path "book_covers/<instance_uuid>/cover.<ext>".

// Define Book class inheriting from models.Model:
//   Define VISIBILITY_CHOICES: ('public', 'Public'), ('private', 'Private').

//   Define fields:
//     uuid: UUIDField, default is new UUID, not editable, unique, indexed.
//     title: CharField, max_length 255.
//     author: CharField, max_length 255.
//     language: CharField, max_length 50.
//     category: CharField, max_length 100.
//     tags: CharField, max_length 255, blank allowed.
//     description: TextField, blank allowed.
//     publisher: CharField, max_length 255, blank allowed.
//     publish_date: DateField, null and blank allowed.
//     isbn: CharField, max_length 20, blank allowed.
//     page_count: IntegerField, null and blank allowed.
//     visibility: CharField, max_length 10, choices from VISIBILITY_CHOICES, default 'public'.
//     allow_comments: BooleanField, default True.
//     cover_image: ImageField, uploads to path from cover_image_upload_path, blank and null allowed.
//     book_file: FileField, uploads to path from book_file_path, null allowed.
//     user: ForeignKey to AUTH_USER_MODEL, on_delete CASCADE, related_name 'books'.
//     created_at: DateTimeField, auto_now_add True.
//     updated_at: DateTimeField, auto_now True.
//     rating: FloatField, default 0.

//   Define method __str__(self):
//     Return "self.title by self.author".

//   Define method delete(self, *args, **kwargs):
//     If book_file exists and is a file, delete it from filesystem.
//     If cover_image exists and is a file, delete it from filesystem.
//     Call super().delete(*args, **kwargs).
```

**字段说明:**

- `uuid`: UUID 字段，书籍的唯一标识符，自动生成且不可编辑。
- `title`: CharField，书名，最大长度 255。
- `author`: CharField，作者，最大长度 255。
- `language`: CharField，书籍语言，最大长度 50。
- `category`: CharField，书籍分类，最大长度 100。
- `tags`: CharField，标签，最大长度 255，可为空。
- `description`: TextField，书籍描述，可为空。
- `publisher`: CharField，出版商，最大长度 255，可为空。
- `publish_date`: DateField，出版日期，可为空。
- `isbn`: CharField，ISBN 号，最大长度 20，可为空。
- `page_count`: IntegerField，页数，可为空。
- `visibility`: CharField，可见性设置（'public' 或 'private'），默认为 'public'。
- `allow_comments`: BooleanField，是否允许评论，默认为 True。
- `cover_image`: ImageField，封面图片文件。上传路径由 `cover_image_upload_path` 函数动态生成，存储在 `media/book_covers/<book_uuid>/cover.<ext>`。可为空。
- `book_file`: FileField，书籍文件 (例如 EPUB)。上传路径由 `book_file_path` 函数动态生成，存储在 `media/books/<uuid>.<ext>`。可为空。
- `user`: ForeignKey，关联到 `CustomUser` 模型，表示书籍的上传者/所有者。采用级联删除。
- `created_at`: DateTimeField，创建时间，自动记录。
- `updated_at`: DateTimeField，最后更新时间，自动记录。
- `rating`: FloatField，书籍评分，默认为 0。

**辅助函数:**

- `book_file_path(instance, filename)`: 生成书籍文件的唯一存储路径。文件名将使用 UUID 重命名以避免冲突。
- `cover_image_upload_path(instance, filename)`: 生成封面图片的唯一存储路径。封面图片将存储在以书籍 UUID 命名的子目录下。

**方法:**

- `__str__(self)`: 返回书籍的可读字符串表示形式（"书名 by 作者"）。
- `delete(self, *args, **kwargs)`: 重写了删除方法，在删除书籍记录的同时，也会从文件系统中删除关联的封面图片和书籍文件。

## 4. 项目结构 (Project Structure)

### 4.1. Django 后端 (`bookapp_django`)

```
bookapp_django/
├── bookapp_django/         # Django 项目配置目录
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py         # 项目设置
│   ├── urls.py             # 项目总路由
│   └── wsgi.py
├── books/                  # 书籍管理应用
│   ├── migrations/         # 数据库迁移文件
│   ├── __init__.py
│   ├── admin.py            # Django Admin 配置
│   ├── apps.py
│   ├── models.py           # 书籍数据模型
│   ├── serializers.py      # DRF Serializers
│   ├── tests.py
│   ├── urls.py             # 书籍应用路由
│   └── views.py            # 视图逻辑
├── corsheaders_fix/        # (可能为自定义的CORS处理，或已废弃)
├── media/                  # 用户上传文件存储目录 (例如书籍文件, 封面)
│   ├── book_covers/        # 书籍封面图片
│   └── books/              # 书籍文件 (EPUB等)
├── users/                  # 用户管理应用
│   ├── migrations/         # 数据库迁移文件
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py           # 用户数据模型 (CustomUser)
│   ├── serializers.py      # DRF Serializers
│   ├── tests.py
│   ├── urls.py             # 用户应用路由
│   └── views.py            # 视图逻辑
├── bookapppvenv/           # Python 虚拟环境 (通常在项目外层，此处列出仅为结构参考)
├── db.sqlite3              # SQLite 数据库文件 (开发用)
└── manage.py               # Django 管理脚本
```

**关键目录和文件说明:**

- `bookapp_django/settings.py`: Django 项目的主要配置文件，包括数据库设置、中间件、静态文件、媒体文件路径等。
- `bookapp_django/urls.py`: 项目的根 URL 配置，它会包含各个 app 的 URL 配置。
- `books/models.py`: 定义了 `Book` 模型，包括书籍的各种属性和文件存储逻辑。
- `users/models.py`: 定义了 `CustomUser` 模型，扩展了 Django 的默认用户模型。
- `books/views.py` 和 `users/views.py`: 处理 HTTP 请求，包含业务逻辑，通常与 serializers 交互以处理数据。
- `books/serializers.py` 和 `users/serializers.py`: 使用 Django REST Framework 将模型实例转换为 JSON 等格式，并进行数据验证。
- `media/`: 存储用户上传的文件。`book_file_path` 和 `cover_image_upload_path` 函数定义了文件在此目录下的具体存储路径和命名规则。

### 4.2. Vue 前端 (`bookapp_vuetify`)

```
bookapp_vuetify/
├── .vscode/                # VS Code 编辑器配置
├── android/                # Capacitor 生成的 Android 项目目录
├── dist/                   # 项目构建后的输出目录
├── node_modules/           # npm 包依赖
├── public/                 # 公共静态资源
│   └── favicon.ico
├── src/
│   ├── assets/             # 静态资源 (图片, 字体等)
│   │   └── logo.svg
│   ├── components/         # Vue 组件
│   │   ├── HomePage.vue    # 平台介绍页
│   │   └── NavBar.vue      # 导航栏组件
│   ├── pages/              # 页面级 Vue 组件 (通常对应路由)
│   │   ├── addBook.vue     # 添加/编辑书籍页面
│   │   ├── book.vue        # 单个书籍详情与阅读页面
│   │   ├── books.vue       # 书籍列表页面
│   │   ├── index.vue       # 平台介绍页
│   │   ├── login.vue       # 登录页面
│   │   ├── profile.vue     # 用户个人资料页面
│   │   └── register.vue    # 用户注册页面
│   ├── plugins/            # Vuetify, Pinia 等插件配置
│   │   ├── index.ts
│   │   ├── pinia.ts
│   │   └── vuetify.ts
│   ├── router/             # Vue Router 配置
│   │   └── index.ts
│   ├── services/           # API 服务调用 (例如 axios 实例和请求封装)
│   │   └── apiClient.ts
│   ├── stores/             # Pinia状态管理
│   │   ├── auth.js         # 用户认证状态
│   │   └── book.js         # (可能用于书籍相关状态)
│   ├── App.vue             # 根 Vue 组件
│   └── main.ts             # 应用入口文件
├── .browserslistrc
├── .editorconfig
├── .eslintrc.json
├── .gitignore
├── .prettierrc
├── capacitor.config.json   # Capacitor 配置文件 (用于打包移动应用)
├── env.d.ts                # TypeScript 环境变量声明
├── eslint.config.js        # ESLint 配置文件
├── index.html              # SPA 的主 HTML 文件
├── package.json            # 项目依赖和脚本配置
├── package-lock.json
├── README.md
├── tsconfig.app.json       # TypeScript 应用编译配置
├── tsconfig.json           # TypeScript 基础配置
├── tsconfig.node.json      # TypeScript Node环境编译配置
└── vite.config.mts         # Vite 构建工具配置
```

**关键目录和文件说明:**

- `vite.config.mts`: Vite 项目的构建和开发服务器配置。
- `public/`: 存放不会被 Webpack/Vite 处理的静态资源，它们会被直接复制到构建输出的根目录。
- `capacitor.config.json`: Capacitor 的核心配置文件。它定义了应用的基本信息（如应用 ID `appId`, 应用名称 `appName`），以及 Web 应用的构建产物目录 (`webDir`)，这里通常是 `dist`。此文件还用于配置 Capacitor 插件和平台特定设置。
- `android/`: 由 Capacitor CLI 生成和管理的 Android 原生项目目录。当执行 `npx cap add android` 和后续同步命令 (`npx cap sync android`) 后，Capacitor 会将 Web 应用资源复制到此目录，并配置好一个标准的 Android Studio 项目。开发者可以在 Android Studio 中打开此项目，进行原生代码的修改、依赖管理、签名和最终 APK 的构建。

## 5. 已实现功能代码及解释 (Implemented Features Code and Explanation)

### 5.1. 用户认证 (User Authentication)

用户认证系统是平台的核心功能之一，包括用户注册、登录、登出以及后续可能的个人资料管理。

#### 5.1.1. 用户注册

**前端 (`bookapp_vuetify/src/pages/register.vue`):**

用户通过注册页面 (`register.vue`) 输入用户名、邮箱、密码，并可选择擅长语言。表单包含输入验证规则。

- **UI 组件**: 使用 Vuetify 组件 (`v-text-field`, `v-autocomplete`, `v-btn`, `v-form`, `v-alert`) 构建注册表单。
- **数据提交**: 点击“注册”按钮后，`register()` 方法被调用。
  - 它首先进行表单验证 (`isFormValid`) 和网络连接检查 (`mobileService.checkNetwork()`).
  - 然后通过 `fetch` API 将用户输入的数据 (username, email, password, languages) 以 POST 请求发送到后端注册接口 `http://localhost:8000/api/auth/register/`.
  - 根据响应结果，显示成功或错误消息，并在成功后跳转到登录页面。

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages\register.vue

// Define asynchronous function register():
//   If form is not valid, then exit.
//   Try:
//     Set isLoading to true.
//     Clear errorMessage.
//     Check network connection using mobileService.checkNetwork().
//     If not connected:
//       Set errorMessage to "网络连接错误，请检查您的网络".
//       Set isLoading to false.
//       Exit.
//     Make a POST request to 'http://localhost:8000/api/auth/register/' with:
//       Headers: 'Content-Type': 'application/json'.
//       Body: JSON string of { username, email, password, languages }.
//     If response is not OK:
//       Try to parse errorData from response JSON.
//       Set errorMessage to errorData.detail or "注册失败，请重试".
//       Set isLoading to false.
//       Exit.
//     Show toast message "注册成功！请登录" using mobileService.showToast().
//     Navigate to '/login' page using router.push().
//   Catch error:
//     Log "Registration error:" and the error.
//     Set errorMessage to "注册过程中发生错误".
//   Finally:
//     Set isLoading to false.
```

**后端 (`bookapp_django/users/views.py` & `bookapp_django/users/serializers.py`):**

- **路由**: Django 项目的 `urls.py` (未直接提供，但通常会配置) 将 `/api/auth/register/` 路径指向 `users.views.RegisterView`.
- **视图 (`RegisterView`):**
  - 继承自 `rest_framework.generics.CreateAPIView`, 专门用于处理创建新对象的请求。
  - `queryset`: `get_user_model().objects.all()`
  - `permission_classes`: `[AllowAny]` 允许任何用户访问此接口进行注册。
  - `serializer_class`: `RegisterSerializer` 用于验证和处理注册数据。

```pseudocode
// File: d:\Documents\GitHub\Figado\bookapp_django\users\views.py

// Import CreateAPIView from rest_framework.generics.
// Import AllowAny from rest_framework.permissions.
// Import get_user_model from django.contrib.auth.
// Import RegisterSerializer from local serializers.

// Define class RegisterView inheriting from CreateAPIView:
//   Set queryset to all objects of the user model (get_user_model().objects.all()).
//   Set permission_classes to [AllowAny] (allows access without authentication).
//   Set serializer_class to RegisterSerializer.
```

- **序列化器 (`RegisterSerializer`):**
  - 继承自 `serializers.ModelSerializer`.
  - `Meta.model`: `get_user_model()` (即 `CustomUser`).
  - `Meta.fields`: `('username', 'email', 'password', 'languages')`.
  - `password`: 设置为 `write_only=True`, 最小长度为 8.
  - `languages`: `ListField`, 同样 `write_only=True`, 非必需。
  - `create(self, validated_data)`: 重写了 `create` 方法，用于创建新用户。
    - 它会从 `validated_data` 中弹出 `languages`.
    - 使用 `User.objects.create_user()` 创建用户，该方法会自动处理密码哈希。
    - 将 `languages` 赋值给新创建的用户实例并保存。

```pseudocode
// File: d:\Documents\GitHub\Figado\bookapp_django\users\serializers.py

// Import serializers from rest_framework.
// Import get_user_model from django.contrib.auth.

// Define class RegisterSerializer inheriting from serializers.ModelSerializer:
//   Define password field: CharField, write_only, min_length 8.
//   Define languages field: ListField of CharFields, write_only, not required, default empty list.

//   Define Meta class:
//     Set model to the user model (get_user_model()).
//     Set fields to ('username', 'email', 'password', 'languages').

//   Define method create(self, validated_data):
//     Get User model.
//     Extract 'languages' from validated_data (default to empty list if not present).
//     Create a new user using User.objects.create_user() with:
//       username from validated_data.
//       email from validated_data (default to empty string if not present).
//       password from validated_data.
//     Set the new user's languages attribute.
//     Save the user.
//     Return the user.
```

#### 5.1.2. 用户登录

**前端 (`bookapp_vuetify/src/pages/login.vue`):**

用户通过登录页面 (`login.vue`) 输入用户名和密码。

- **UI 组件**: 使用 Vuetify 组件 (`v-text-field`, `v-btn`, `v-form`, `v-alert`) 构建登录表单。
- **数据提交**: 点击“登录”按钮后，`login()` 方法被调用。
  - 进行表单验证和网络检查。
  - 通过 `fetch` API 将用户名和密码以 POST 请求发送到后端登录接口 `http://localhost:8000/api/auth/login/`.
  - **Token 处理**: 如果登录成功，后端会返回 `access` 和 `refresh` tokens。
    - 这些 tokens 以及用户名被存储在 `localStorage` 中。
    - `auth.setToken(data.access)` 和 `auth.setUsername(username.value)` 更新 Pinia store (auth.js/ts) 中的状态。
  - 成功登录后，用户被重定向到个人资料页面 (`/profile`).

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages\login.vue

// Define asynchronous function login():
//   If form is not valid, then exit.
//   (Assume network check is performed here)
//   Try:
//     Make a POST request to 'http://localhost:8000/api/auth/login/' with:
//       Headers: 'Content-Type': 'application/json'.
//       Body: JSON string of { username, password }.
//     If response is not OK:
//       (Handle error, set errorMessage, set isLoading to false, and exit)
//       Set errorMessage to errorData.detail or "登录失败 (status_code)".
//       Set isLoading to false.
//       Return.
//     Parse response JSON into data.
//     Store 'data.access' token in localStorage as 'access'.
//     Store 'data.refresh' token in localStorage as 'refresh'.
//     Store 'username.value' in localStorage as 'username'.
//     Update Pinia auth store:
//       Call auth.setToken(data.access).
//       Call auth.setUsername(username.value).
//     Show toast message "登录成功！" using mobileService.showToast().
//     Navigate to '/profile' page using router.push().
//   Catch error:
//     (Handle error)
//   (Finally block might set isLoading to false)
```

**后端 (Django REST Framework Simple JWT - 典型实现):**

虽然未直接提供登录视图代码，但 Django REST Framework 项目通常使用 `rest_framework_simplejwt` 库来处理 JWT (JSON Web Token) 认证。

- **路由**: `/api/auth/login/` 通常会映射到 `TokenObtainPairView` from `rest_framework_simplejwt.views`.
- **`TokenObtainPairView`**: 这个视图接收用户名和密码，验证凭据。
  - 如果凭据有效，它会生成并返回一个新的 access token 和 refresh token。
  - Access token 用于后续 API 请求的认证。
  - Refresh token 用于在 access token 过期时获取新的 access token，而无需用户重新登录。
- **Token 验证**: 受保护的 API 端点会使用 JWTAuthentication 类来验证请求头中提供的 access token。

**状态管理 (Pinia - `auth.js` or `auth.ts`):**

虽然 `auth.js` 文件未找到，但从 `login.vue` 的代码 `import { useAuthStore } from '@/stores/auth'` 和 `auth.setToken()` / `auth.setUsername()` 的使用来看，存在一个 Pinia store 用于管理认证状态。

- **Store 结构 (推测):**
  - `token`: 存储 access token。
  - `username`: 存储当前登录用户的用户名。
  - `isAuthenticated`: 一个 getter，根据 token 是否存在来判断用户是否已登录。
  - Actions: `setToken`, `setUsername`, `logout` (清除 token 和用户信息).
- **持久化**: Token 通常存储在 `localStorage` 中，以便在页面刷新后保持登录状态。Pinia store 在初始化时会尝试从 `localStorage` 加载 token。

#### 5.1.3. 用户登出

**前端 (`bookapp_vuetify/src/pages/profile.vue`):**

用户个人资料页面 (`profile.vue`) 提供了登出功能。

- **UI**: 登出按钮触发 `confirmLogout` 方法，显示确认对话框。
- **`logout()` 方法**: (代码未完全展示，但基于典型实现)
  - 调用 Pinia store 中的 `logout` action。
  - 该 action 会清除 `localStorage` 中的 `access` token, `refresh` token 和 `username`.
  - 清除 Pinia store 中的认证状态 (token, username).
  - 将用户重定向到登录页面 (`/login`).

```pseudocode
// Snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages\profile.vue (illustrative for logout)

// (Template contains logout button and confirmation dialog)

// In script setup:
//   Get auth store instance (useAuthStore).
//   Get router instance.
//   Define logoutDialog ref, initially false.

//   Define function confirmLogout():
//     Set logoutDialog.value to true.

//   Define asynchronous function logout():
//     Call auth.logout() action from Pinia store.
//       (This action should clear localStorage tokens/user info and reset store state).
//     Set logoutDialog.value to false.
//     Navigate to '/login' page using router.push().
//     Optionally, show toast message "您已成功退出登录" using mobileService.showToast().
```

**后端**: JWT 是无状态的。登出主要在客户端通过删除 token 实现。后端可以通过维护一个 token 黑名单来实现更严格的登出（使已签发的 token 失效），但这通常需要额外的设置。

#### 5.1.4. 个人资料查看与编辑

**前端 (`bookapp_vuetify/src/pages/profile.vue`):**

- **显示信息**: 从 `localStorage` 或 Pinia store 获取用户名 (`username`) 和用户偏好语言 (`userLanguages`) 并显示。
- **编辑功能**: `openEditProfile` 打开编辑弹窗，允许用户修改用户名、邮箱和语言偏好。
  - `saveProfile` 方法 (未提供具体实现) 将会调用后端 API 更新用户信息。

**后端**: 需要相应的 API 端点来获取和更新用户信息。

- 获取用户信息: 通常是一个 `/api/auth/user/` 或 `/api/profile/` 的 GET 请求，需要认证。
- 更新用户信息: 同一个端点的 PUT 或 PATCH 请求，包含要更新的数据。
  - 对应的 Django 视图会使用类似 `UserSerializer` (可能需要一个新的，或扩展现有的) 来处理和验证数据，然后更新 `CustomUser` 模型实例。

#### 5.1.5. Pinia Store (`auth.ts`)

This Pinia store (`useAuthStore`) manages the authentication state:

- `accessToken`: Stores the JWT access token, initialized from `localStorage`.
- `username`: Stores the logged-in user's name, initialized from `localStorage`.
- `loggedIn`: A computed property that returns `true` if `accessToken` is present, indicating an active session.
- `setToken(token)`: Action to update `accessToken` in both the store and `localStorage`.
- `setUsername(name)`: Action to update `username` in both the store and `localStorage`.
- `logout()`: Action to clear `accessToken` and `username` from the store and remove `access`, `refresh`, and `username` items from `localStorage`.
- An event listener for `storage` changes ensures that if authentication state changes in another browser tab (e.g., user logs out), the current tab's state is updated accordingly.

### 5.2. 书籍管理 (Book CRUD Operations)

平台的核心功能是书籍的上传、展示、管理和阅读。这包括书籍的创建 (Create)、读取 (Read)、更新 (Update) 和删除 (Delete) 操作，以及文件处理。

#### 5.2.1. 后端实现 (`bookapp_django`)

**模型 (`books.models.Book`):**

(已在 3.2. `books.models.Book` 章节详细描述)

**序列化器 (`books.serializers.py`):**

- `BookSerializer`: 用于书籍的创建、检索、更新。包含所有字段，并对 `user` 字段设为只读 (从请求用户自动获取)。特别地，它有一个 `validate_book_file` 方法，用于校验上传的文件是否为 EPUB 格式 (通过文件扩展名和 `python-magic` 库检测 MIME 类型)。

```pseudocode
// File: d:\Documents\GitHub\Figado\bookapp_django\books\serializers.py

// Import serializers from rest_framework.
// Import Book model from local models.
// Import os module.
// Import magic module (for MIME type validation).

// Define class BookSerializer inheriting from serializers.ModelSerializer:
//   Define user field: ReadOnlyField, source is 'user.username'.

//   Define Meta class:
//     Set model to Book.
//     Set fields to include all Book model fields (id, title, author, ..., rating).
//     Set read_only_fields to ['user', 'created_at', 'updated_at'].

//   Define method validate_book_file(self, value):
//     If value (book file) is not provided, return value.
//     Get file extension from value.name.
//     If extension is not '.epub', raise ValidationError "Only EPUB files are allowed.".
//     Try:
//       Read first 1024 bytes of the file to get MIME type using magic.from_buffer().
//       Reset file read pointer to beginning (value.seek(0)).
//       Define valid_mimes = ['application/epub+zip', 'application/octet-stream'].
//       If detected file_mime is not in valid_mimes, raise ValidationError "Invalid file type...".
//     Catch ImportError (if python-magic is not installed):
//       Pass (fallback to extension check).
//     Return value.

// Define class BookListSerializer inheriting from serializers.ModelSerializer:
//   Define user field: ReadOnlyField, source is 'user.username'.
//   Define Meta class:
//     Set model to Book.
//     Set fields to a subset for list view: ['id', 'title', 'author', 'category', 'cover_image', 'visibility', 'user', 'created_at', 'updated_at', 'rating'].
//     Set read_only_fields to ['user', 'created_at', 'updated_at'].
```

- `BookListSerializer`: 用于书籍列表展示，包含较少的关键字段，以提高列表加载效率。

**视图 (`books.views.py`):**

- `BookViewSet`:
  - 继承自 `viewsets.ModelViewSet`，自动提供 `list`, `create`, `retrieve`, `update`, `partial_update`, `destroy` 动作。
  - `permission_classes`: `[permissions.IsAuthenticated, IsOwnerOrReadOnly]`。用户必须登录才能访问，且只有书籍所有者才能编辑或删除。
  - `parser_classes`: `[MultiPartParser, FormParser]` 支持文件上传。
  - `filter_backends`: `[filters.SearchFilter, filters.OrderingFilter]` 支持搜索和排序。
  - `search_fields`: 定义了可供搜索的字段。
  - `get_serializer_class()`: 列表视图使用 `BookListSerializer`，其他视图使用 `BookSerializer`。
  - `get_queryset()`: 返回当前用户的所有书籍以及其他用户的公开书籍。
  - `perform_create(serializer)`: 创建书籍时，自动将当前登录用户设为书籍的 `user`。
  - `download(request, pk=None)`: 自定义 action (`@action(detail=True, methods=['get'])`)，允许用户下载书籍的 EPUB 文件。它会检查文件是否存在并返回 `FileResponse`。

```pseudocode
// File: d:\Documents\GitHub\Figado\bookapp_django\books\views.py

// Import necessary modules from rest_framework, Django, and local app.
// Import os module.

// Define class IsOwnerOrReadOnly inheriting from permissions.BasePermission:
//   Define method has_object_permission(self, request, view, obj):
//     If request method is safe (GET, HEAD, OPTIONS):
//       If object's visibility is 'public', return True.
//       Return True if object's user is the request user, else False.
//     Else (for unsafe methods like POST, PUT, DELETE):
//       Return True if object's user is the request user, else False.

// Define class BookViewSet inheriting from viewsets.ModelViewSet:
//   Set queryset to all Book objects.
//   Set serializer_class to BookSerializer (default).
//   Set permission_classes to [IsAuthenticated, IsOwnerOrReadOnly].
//   Set parser_classes to [MultiPartParser, FormParser] (for file uploads).
//   Set filter_backends to [SearchFilter, OrderingFilter].
//   Set search_fields to ['title', 'author', 'description', 'tags', 'category'].
//   Set ordering_fields to ['title', 'author', 'created_at', 'updated_at'].

//   Define method get_serializer_class(self):
//     If action is 'list', return BookListSerializer.
//     Else, return BookSerializer.

//   Define method get_queryset(self):
//     Get current user from request.
//     Return a queryset containing:
//       All books owned by the current user.
//       OR all books with 'public' visibility.

//   Define method perform_create(self, serializer):
//     Save the serializer, setting the book's user to the current request user.

//   Define action download(self, request, pk=None) (detail=True, methods=['get']):
//     Get the book object.
//     If book has no book_file or path, return 404 Response "No book file available".
//     Get file_path from book.book_file.path.
//     If file_path exists:
//       Create FileResponse with the opened file ('rb' mode) and content_type 'application/epub+zip'.
//       Set filename for download (e.g., "book.title.epub" or "book.epub").
//       Ensure filename is ASCII or properly URI encoded.
//       Set 'Content-Disposition' header for attachment with the filename.
//       Return the FileResponse.
//     Else (file not found):
//       Return 404 Response "File not found".
```

- `IsOwnerOrReadOnly` 权限类: 自定义权限，确保只有书籍的创建者才能修改或删除它。对于公开书籍，任何人都可以读取；对于私有书籍，只有创建者可以读取。

#### 5.2.2. 前端实现 (`bookapp_vuetify`)

**列出书籍 (`src/pages/books.vue`):**

- **获取数据**: `onMounted` 和 `fetchBooks` 方法通过 `ApiServiceDebug.get('/api/books/', auth.accessToken)` 从后端获取书籍列表。
- **展示**: 使用 `v-row` 和 `v-col` 循环 `books` 数组，每本书籍以 `v-card` 展示，包含封面 (`v-img`)、标题、作者、评分 (`v-rating`)、分类和描述。
- **交互**: 点击书籍卡片会调用 `viewBookDetails(book.id)`，使用 `router.push` 跳转到书籍详情页。
- **状态处理**: 包含加载中 (`isLoading`)、网络错误 (`networkError`) 和无结果 (`books.length === 0`) 的用户提示。
- **搜索**: 包含一个 `v-text-field` 用于输入搜索词，`searchBooks` 方法会带上 `search` 查询参数请求 `/api/books/`。

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages\books.vue
// (Template includes elements for book list, search, loading, and error states)

// Define asynchronous function fetchBooks():
//   Try:
//     Set isLoading to true.
//     Set networkError to false.
//     (Assume network check is performed).
//     Fetch rawBooks data from '/api/books/' using ApiServiceDebug.get() with auth token.
//     Map rawBooks to a new array 'books.value', transforming each book object:
//       id, title, author, coverUrl (from book.cover_image or empty string),
//       rating (numeric or 0), category, language, description.
//     Set isLoading to false.
//   Catch error:
//     (Handle error, e.g., set networkError to true, isLoading to false).

// Define asynchronous function searchBooks():
//   Try:
//     Set isLoading to true.
//     Set networkError to false.
//     (Assume network check is performed).
//     Create URLSearchParams object.
//     If searchQuery.value exists, append 'search' parameter with its value.
//     Construct URL: `/api/books/?${params.toString()}`.
//     Fetch rawBooks data from the constructed URL using ApiServiceDebug.get() with auth token.
//     (Map rawBooks to books.value, similar to fetchBooks).
//     Set isLoading to false.
//   Catch error:
//     (Handle error).

// Define function viewBookDetails(bookId: number):
//   Navigate to `/book/${bookId}` page using router.push().
```

**查看书籍详情 (`src/pages/book.vue`):**

- **获取数据**: `fetchBook` 方法根据路由参数中的 `id`，通过 `ApiServiceDebug.get(`/api/books/${bookId}/`, auth.accessToken)` 获取特定书籍的详细信息。
- **展示**: 显示书籍的封面、标题、作者、分类、语言、评分、简介等。
- **操作按钮**: 提供“下载 EPUB”和“在线阅读”按钮。
  - `downloadEpub`: 调用后端 `/api/books/{id}/download/` 端点下载文件。
  - `readEpubOnline`: (详见 5.3 EPUB 文件处理与在线阅读)

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages\book.vue
// (Template includes elements for displaying book details)

// Define asynchronous function fetchBook():
//   Try:
//     Set isLoading to true.
//     Set networkError to false.
//     (Assume network check is performed).
//     Get bookId from route.params.id.
//     Fetch raw book data from `/api/books/${bookId}/` using ApiServiceDebug.get() with auth token.
//     Set 'book.value' by mapping fields from raw data:
//       id, title, author, coverUrl (from raw.cover_image or empty string),
//       rating (numeric or 0), category, language, description.
//     Set isLoading to false.
//   Catch error:
//     (Handle error).

// Define asynchronous function downloadEpub():
//   If book.value or book.value.id is not available, then exit.
//   (Assume baseUrl is defined).
//   Construct URL: `${baseUrl}/api/books/${book.value.id}/download/`.
//   Try:
//     Fetch from the URL with Authorization header (Bearer token).
//     (Handle response: check if OK, get blob, create object URL, create link, click to download).
//   Catch error e:
//     Show alert "下载失败：" + e.
```

**添加/编辑书籍 (`src/components/AddBook.vue`):**

此组件用于创建新书，也可以扩展用于编辑现有书籍（通过传入 `props` 来预填表单并改变提交目标 API 和方法）。

- **表单**: 使用 `v-form` 和各种 Vuetify 输入组件 (`v-text-field`, `v-select`, `v-textarea`, `v-file-input`, `v-rating`) 收集书籍信息。
- **封面上传**: `coverImage` (File object) 和 `coverPreview` (data URL)。
  - 支持从文件选择 (`v-file-input`)、拍照 (`captureCover` 使用 `mobileService.takePicture()`)、从相册选择 (`selectCoverFromGallery` 使用 `mobileService.selectFromGallery()`）。
  - `previewCover` 方法用于生成本地预览。
- **EPUB 文件上传**: `bookFile` (File object)。
  - `onEpubFileChange`: 当用户选择 EPUB 文件后，此方法使用 `EpubJS` 库在前端解析文件元数据 (标题, 作者, 描述, 语言, 封面等)，并自动填充表单对应字段。
- **数据提交 (`submitBook`):**
  - 进行表单验证 (`isFormValid`) 和网络检查。
  - 创建一个 `FormData` 对象，将所有书籍数据（包括封面文件 `coverImage.value` 和书籍文件 `bookFile.value`）附加到其中。
  - 使用 `fetch` API 将 `FormData` 以 POST 请求发送到 `/api/books/` (创建新书)。对于编辑，通常会发送 PUT 或 PATCH 请求到 `/api/books/{id}/`。
  - 处理响应，成功后显示成功对话框 (`showSuccessDialog`) 并触发 `success` 事件。
- **重置表单 (`resetForm`):** 清空所有输入和文件选择。

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\components\AddBook.vue
// (Template includes an extensive form for book data)

// EPUB Metadata Parsing
// Define asynchronous function onEpubFileChange(file: File | null):
//   If no file is provided, then exit.
//   Try:
//     Create an object URL (epubFileUrl) from the file.
//     Initialize EpubJS bookInstance (EpubJS.default()).
//     Open the epubFileUrl with bookInstance.
//     (Show toast message for loading).
//     Wait for bookInstance.loaded.metadata to get metadata.
//     If metadata.title exists, set bookData.title.
//     If metadata.creator exists, set bookData.author.
//     (Fill other bookData fields like description, language, publisher, isbn from metadata).
//     When bookInstance.loaded.cover is available:
//       If coverUrl exists:
//         Create a base64 URL for the cover using bookInstance.archive.createUrl().
//         Set coverPreview.value to this base64 URL.
//         Fetch the base64 URL, convert response to blob.
//         Create a new File object ('cover.jpg') from the blob.
//         Set coverImage.value to this File object.
//     (Show toast message for metadata loaded).
//   Catch error err:
//     (Handle error, e.g., show error toast).

// Form Submission
// Define asynchronous function submitBook():
//   If form is not valid (isFormValid.value is false), then exit.
//   (Assume network check is performed).
//   Set isSubmitting.value to true.
//   Create a new FormData object.
//   Append 'title' with bookData.title to formData.
//   (Append all other bookData fields to formData).
//   If coverImage.value exists, append 'cover_image' with coverImage.value to formData.
//   If bookFile.value exists, append 'book_file' with bookFile.value to formData.
//   Get 'access' token from localStorage.
//   Make a POST request to 'http://localhost:8000/api/books/' (or PUT/PATCH for editing) with:
//     Headers: Authorization: `Bearer ${token}` (if token exists).
//     Body: formData.
//   If response is not OK:
//     (Handle error, set isSubmitting to false, and return).
//   Parse response JSON into data.
//   Set newBookId.value to data.id.
//   Set showSuccessDialog.value to true.
//   Emit 'success' event with newBookId.value.
//   (Set isSubmitting.value to false in a finally block or after success/error).
```

**删除书籍 (主要在 `profile.vue` 中实现):**

- 用户在自己的书籍列表中，可以找到删除按钮。
- 点击删除按钮通常会弹出一个确认对话框 (`v-dialog`)。
- 确认后，前端会向后端发送 DELETE 请求到 `/api/books/{id}/`。
- 成功删除后，前端会更新书籍列表，移除被删除的书籍。

```pseudocode
// Illustrative snippet for delete functionality (e.g., in profile.vue)
// (Template includes delete button and confirmation dialog)

// Define asynchronous function deleteBook(bookId: number):
//   (Show confirmation dialog).
//   If deletion is confirmed:
//     Try:
//       Get 'access' token from localStorage.
//       Make a DELETE request to `http://localhost:8000/api/books/${bookId}/` with:
//         Headers: Authorization: `Bearer ${token}` (if token exists).
//       If response is not OK:
//         Show toast "删除失败" using mobileService.showToast().
//         Exit.
//       Show toast "书籍已删除" using mobileService.showToast().
//       Refresh book list (e.g., call fetchUserBooks() or remove from local array).
//     Catch error:
//       Log "Error deleting book:" and the error.
//       Show toast "删除过程中发生错误" using mobileService.showToast().
```

### 5.3. EPUB 文件处理与在线阅读

此功能允许用户上传 EPUB 文件，并在网页端直接阅读。

**EPUB 上传与元数据解析:**

(已在 `AddBook.vue` 部分描述) - 前端使用 `EpubJS` 在选择 EPUB 文件后，自动解析其元数据（书名、作者、封面等）并填充到表单中。后端 `BookSerializer` 的 `validate_book_file` 确保了文件格式的正确性。

**EPUB 下载:**

(已在 `book.vue` 和 `BookViewSet` 的 `download` action 中描述) - 用户可以从书籍详情页下载原始 EPUB 文件。

**在线阅读 (`src/pages/book.vue` 使用 `epub.js`):**

- **触发**: 点击“在线阅读”按钮调用 `readEpubOnline` 方法。
- **EPUB 加载**: `readEpubOnline` 方法首先获取书籍的下载链接 (`/api/books/{id}/download/`)，然后使用 `fetch` API 下载 EPUB 文件内容为 `ArrayBuffer`。
- **`epub.js` 初始化**: `ePub(arrayBuffer)` 使用获取到的 `ArrayBuffer` 初始化 `epub.js` 的 `Book` 实例。
- **渲染**: `bookInstance.renderTo('epub-viewer', { width: '100%', height: '80vh' })` 将书籍渲染到页面上 ID 为 `epub-viewer` 的 `div` 元素中。`rendition.display()` 显示第一页。
- **目录 (TOC)**:
  - `bookInstance.loaded.navigation.then(nav => { epubToc.value = nav.toc || [] })` 获取书籍的目录结构并存储在 `epubToc` ref 中。
  - 目录展示在阅读器左侧的 `v-list` 中。点击目录项 (`goToToc(item)`) 会使用 `rendition.display(item.href)` 跳转到相应章节。
  - 当前章节在目录中会高亮显示 (`tocActiveId` ref 与 `rendition.on('rendered', section => { tocActiveId.value = section.href })` 配合)。
- **翻页**: “上一页” (`prevPage`) 和“下一页” (`nextPage`) 按钮分别调用 `rendition.prev()` 和 `rendition.next()`。
- **UI**: 阅读器在一个 `v-dialog` 中弹出，包含目录面板 (`.epub-toc-panel`) 和阅读器主区域 (`.epub-viewer-panel`)，使用 Flexbox 布局。

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages\book.vue
// (Template includes EPUB viewer dialog, Table of Contents (TOC), and page navigation buttons)

// Initialize 'rendition' to null (will store epub.js Rendition object).
// Initialize 'epubToc' as a reactive ref array (for TOC items).
// Initialize 'tocActiveId' as a reactive ref string (for active TOC item).

// Define asynchronous function readEpubOnline():
//   If book.value or book.value.id is not available, then exit.
//   Set epubViewer.value to true (to open the dialog).
//   (Assume baseUrl is defined).
//   Construct download URL: `${baseUrl}/api/books/${book.value.id}/download/`.
//   Try:
//     Fetch the EPUB file from the URL with Authorization header (Bearer token).
//     If response is not OK, throw an error "下载失败，状态码：...".
//     Get the response as an ArrayBuffer.
//     Wait for nextTick (to ensure DOM is updated).
//     Get the 'epub-viewer' DOM element.
//     If viewerElement is not found, (handle error and) exit.
//     Clear any previous content from viewerElement.
//     Initialize EpubJS bookInstance with the arrayBuffer: `ePub(arrayBuffer)`.
//     Render the book to 'epub-viewer' element with specified width/height, store result in 'rendition'.
//     Call `rendition.display()` to show the first page.
//     When bookInstance.loaded.navigation is ready:
//       Set epubToc.value to `nav.toc` or an empty array.
//     Listen for 'rendered' event on rendition:
//       When a new section is rendered, update tocActiveId.value with `section.href`.
//   Catch error e:
//     Show alert "加载失败：" + e.
//     Set epubViewer.value to false.
//     Log "EPUB 加载异常:" and the error.

// Define function goToToc(item: any):
//   If rendition, item, and item.href exist:
//     Call `rendition.display(item.href)` to navigate to the chapter.
//     Update tocActiveId.value to `item.id` (for highlighting).

// Define function prevPage():
//   If rendition exists, call `rendition.prev()`.

// Define function nextPage():
//   If rendition exists, call `rendition.next()`.
```

### 5.4. 搜索功能 (Search Functionality)

**前端 (`src/pages/books.vue`):**

- 一个 `v-text-field` 作为搜索输入框。
- 当用户输入并按下 Enter 键 (或通过按钮触发)，`searchBooks` 方法被调用。
- `searchBooks` 方法构造一个带 `search` 查询参数的 URL (例如 `/api/books/?search=keyword`)，然后调用 `ApiServiceDebug.get`.
- 返回的结果会更新 `books` ref，从而刷新列表显示。

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_vuetify\src\pages/books.vue
// (Template includes a v-text-field for search input, triggering searchBooks on enter)

// Define asynchronous function searchBooks():
//   Try:
//     Set isLoading.value to true.
//     Set networkError.value to false.
//     (Assume network check is performed).
//     Create URLSearchParams object.
//     If searchQuery.value exists, append 'search' parameter with its value.
//     Construct URL: `/api/books/?${params.toString()}`.
//     Fetch rawBooks data from the URL using ApiServiceDebug.get() with auth token.
//     Map rawBooks to 'books.value' (transforming each book object as in fetchBooks).
//     Set isLoading.value to false.
//   Catch error:
//     Log "Error searching books:" and the error.
//     Set networkError.value to true.
//     Set isLoading.value to false.
```

**后端 (`books.views.BookViewSet`):**

- `BookViewSet` 配置了 `filter_backends = [filters.SearchFilter, filters.OrderingFilter]`.
- `search_fields = ['title', 'author', 'description', 'tags', 'category']` 指定了 Django REST Framework 的 `SearchFilter` 应该在哪些字段中进行搜索。
- 当请求的 URL 包含 `search` 查询参数时 (例如 `/api/books/?search=keyword`)，`SearchFilter` 会自动过滤查询集，只返回匹配搜索词的书籍。

```pseudocode
// Relevant snippet from d:\Documents\GitHub\Figado\bookapp_django\books\views.py

// In BookViewSet class definition:
//   (Other configurations like queryset, serializer_class, permission_classes exist)
//   Set filter_backends to include [filters.SearchFilter, filters.OrderingFilter].
//   Set search_fields (for SearchFilter) to ['title', 'author', 'description', 'tags', 'category'].
//   (Other parts of the ViewSet definition)
```

### 5.5. 导航栏 (`src/components/NavBar.vue`)

全局导航栏 (`NavBar.vue`) 负责应用的主要导航链接和用户认证状态的展示。

**主要特性:**

- **Logo/标题**: 显示应用名称 "Figaro 书籍分享"，点击可导航至书籍列表页 (`/books`)。
- **响应式设计**:
  - **大屏幕 (d-sm-flex)**: 直接在应用栏显示 "列表"、"登录"/"注册" (未登录时) 或 "个人中心"/"退出" (已登录时) 按钮。

### 5.6. 移动应用打包 (Capacitor for Android)

<!-- TODO: Add details about the packaging process here -->

为了将 `bookapp_vuetify` Vue.js 前端应用扩展到移动端，项目采用了 Capacitor 将其打包为 Android 应用程序 (APK)。
